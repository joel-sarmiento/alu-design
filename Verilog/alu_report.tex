\documentclass{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{geometry}
\geometry{margin=1in}

\title{Group 1 - ALU Integration Final Report}
\author{Cristian Perez, Joel Sarmiento \\ CS3339/CS5339 - Summer 2025}
\date{July 29, 2025}

\lstset{
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  numbers=left,
  numberstyle=\tiny, 
  stepnumber=1,
  numbersep=5pt,
  backgroundcolor=\color{white},
  frame=single,
  breaklines=true,
  escapeinside={(*@}{@*)},
  columns=fullflexible
}

\begin{document}

\maketitle

\section*{Introduction}
This final report documents the comprehensive integration of all ALU modules previously developed in our coursework. The goal was to implement a unified Arithmetic Logic Unit that performs multiple logical and arithmetic operations including AND, OR, NOT, NAND, NOR, shift operations, and more. We created 4-bit, 8-bit, 16-bit, and 32-bit versions for scalability, implemented a control circuit using opcodes, and verified outputs through GTKWave waveform simulation. This report includes all Verilog module and testbench code, operational specifications, and screenshots.

\section*{Operation Code Table}
\begin{center}
\begin{tabular}{|c|c|l|}
\hline
\textbf{Opcode} & \textbf{Operation} & \textbf{Description} \\ \hline
0000 & AND & Bitwise AND of A and B \\ \hline
0001 & OR & Bitwise OR of A and B \\ \hline
0010 & NOT & Bitwise NOT of A \\ \hline
0011 & NAND & Bitwise NAND of A and B \\ \hline
0100 & NOR & Bitwise NOR of A and B \\ \hline
0101 & SHIFT LEFT & Arithmetic shift left of A \\ \hline
0110 & SHIFT RIGHT & Arithmetic shift right of A \\ \hline
\end{tabular}
\end{center}

\section*{Verilog Code: 4-bit ALU}
\begin{lstlisting}[language=Verilog]
module alu(
    input [3:0] A,
    input [3:0] B,
    input [3:0] opcode,
    output reg [3:0] Y
);
    always @(*) begin
        case (opcode)
            4'b0000: Y = A & B;          // AND
            4'b0001: Y = A | B;          // OR
            4'b0010: Y = ~A;             // NOT
            4'b0011: Y = ~(A & B);       // NAND
            4'b0100: Y = ~(A | B);       // NOR
            4'b0101: Y = A << 1;         // Shift Left
            4'b0110: Y = A >> 1;         // Shift Right
            default: Y = 4'b0000;
        endcase
    end
endmodule
\end{lstlisting}

\section*{Verilog Code: 8-bit ALU}
\begin{lstlisting}[language=Verilog]
module alu8(
    input [7:0] A,
    input [7:0] B,
    input [3:0] opcode,
    output reg [7:0] Y
);
    always @(*) begin
        case (opcode)
            4'b0000: Y = A & B;
            4'b0001: Y = A | B;
            4'b0010: Y = ~A;
            4'b0011: Y = ~(A & B);
            4'b0100: Y = ~(A | B);
            4'b0101: Y = A << 1;
            4'b0110: Y = A >> 1;
            default: Y = 8'b00000000;
        endcase
    end
endmodule
\end{lstlisting}

\section*{Verilog Code: 16-bit ALU}
\begin{lstlisting}[language=Verilog]
module alu16(
    input [15:0] A,
    input [15:0] B,
    input [3:0] opcode,
    output reg [15:0] Y
);
    always @(*) begin
        case (opcode)
            4'b0000: Y = A & B;
            4'b0001: Y = A | B;
            4'b0010: Y = ~A;
            4'b0011: Y = ~(A & B);
            4'b0100: Y = ~(A | B);
            4'b0101: Y = A << 1;
            4'b0110: Y = A >> 1;
            default: Y = 16'b0;
        endcase
    end
endmodule
\end{lstlisting}

\section*{Verilog Code: 32-bit ALU}
\begin{lstlisting}[language=Verilog]
module alu32(
    input [31:0] A,
    input [31:0] B,
    input [3:0] opcode,
    output reg [31:0] Y
);
    always @(*) begin
        case (opcode)
            4'b0000: Y = A & B;
            4'b0001: Y = A | B;
            4'b0010: Y = ~A;
            4'b0011: Y = ~(A & B);
            4'b0100: Y = ~(A | B);
            4'b0101: Y = A << 1;
            4'b0110: Y = A >> 1;
            default: Y = 32'b0;
        endcase
    end
endmodule
\end{lstlisting}

\section*{Testbench}
\begin{lstlisting}[language=Verilog]
module alu_tb;
    reg [3:0] A, B, opcode;
    wire [3:0] Y;

    alu uut (.A(A), .B(B), .opcode(opcode), .Y(Y));

    initial begin
        $dumpfile("alu_test.vcd");
        $dumpvars(0, alu_tb);
        A = 4'b1010; B = 4'b0101;
        opcode = 4'b0000; #10;
        opcode = 4'b0001; #10;
        opcode = 4'b0010; #10;
        opcode = 4'b0011; #10;
        opcode = 4'b0100; #10;
        opcode = 4'b0101; #10;
        opcode = 4'b0110; #10;
        $finish;
    end
endmodule
\end{lstlisting}

\section*{GTKWave Simulation}
\begin{center}
\includegraphics[width=0.95\textwidth]{alu_waveform.png}
\end{center}

\section*{Conclusion}
We successfully built and tested an ALU capable of performing basic logical and arithmetic operations. By using Verilog modules and a testbench simulated in GTKWave, we verified correct outputs for all operations. The control logic was cleanly implemented using opcodes. Extra credit was achieved by creating 8-bit, 16-bit, and 32-bit scalable versions. The report was completed in LaTeX to fulfill final submission standards.

\end{document}
